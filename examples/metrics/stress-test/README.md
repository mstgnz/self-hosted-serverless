# Metrics Stress Test Example

This example provides a stress testing tool for generating metrics data by invoking functions at high concurrency.

## Overview

The stress test function allows you to:

1. Invoke a target function multiple times concurrently
2. Run the test for a specified duration
3. Generate a variety of metrics data for analysis
4. Test the performance and reliability of your functions under load

This is particularly useful for:

- Testing how your functions perform under load
- Generating metrics data to visualize in the dashboard
- Identifying performance bottlenecks
- Validating error handling

## How to Use

### Deploy the Function

```bash
serverless deploy -f metrics-stress-test
```

### Run a Stress Test

```bash
# Basic usage with defaults (5 concurrent workers, 60 seconds, targeting custom-metrics)
serverless invoke -f metrics-stress-test

# Custom configuration
serverless invoke -f metrics-stress-test -d '{
  "concurrency": 10,
  "duration": 120,
  "target_function": "my-function"
}'
```

### Parameters

- `concurrency`: Number of concurrent workers (default: 5)
- `duration`: Duration of the test in seconds (default: 60)
- `target_function`: Name of the function to invoke (default: "custom-metrics")

### Monitoring the Test

While the stress test is running, you can:

1. View logs to see real-time progress:

   ```bash
   serverless logs -f metrics-stress-test -t
   ```

2. Open the metrics dashboard to visualize the metrics:
   ```bash
   serverless invoke -f metrics-dashboard
   ```

## Example Workflow

A typical workflow for using the stress test:

1. Deploy the custom-metrics example function:

   ```bash
   serverless deploy -f custom-metrics
   ```

2. Start the metrics dashboard:

   ```bash
   serverless invoke -f metrics-dashboard
   ```

3. Run a stress test against the custom-metrics function:

   ```bash
   serverless invoke -f metrics-stress-test -d '{
     "concurrency": 8,
     "duration": 120,
     "target_function": "custom-metrics"
   }'
   ```

4. Watch the metrics dashboard to see the metrics change in real-time

## How It Works

The stress test function:

1. Starts multiple concurrent workers (goroutines)
2. Each worker repeatedly invokes the target function
3. Workers use random operations to generate diverse metrics
4. The test runs for the specified duration
5. Workers track success and error counts
6. Results are logged when the test completes

## Code Explanation

The key components of the stress test:

- **Worker Pool**: Uses Go's goroutines and wait groups to manage concurrent workers
- **Random Operations**: Generates different types of operations to create varied metrics
- **Controlled Duration**: Runs for a specified time period then gracefully shuts down
- **Result Tracking**: Counts successes and errors for each worker

## Integration with Other Examples

This stress test works well with:

- **Custom Metrics Example**: Target this function to generate custom metrics
- **Metrics Dashboard**: Visualize the metrics generated by the stress test

By combining these examples, you can create a complete metrics testing and visualization workflow.
